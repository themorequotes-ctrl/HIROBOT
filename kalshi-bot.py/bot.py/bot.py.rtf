{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww37860\viewh21260\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import requests\
import json\
import asyncio\
import websockets\
import time\
import os\
import datetime\
import base64\
from cryptography.hazmat.primitives import serialization\
from cryptography.hazmat.primitives.asymmetric import padding\
from cryptography.hazmat.primitives import hashes\
from cryptography.hazmat.backends import default_backend\
import threading\
from telegram import Update\
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, CallbackContext\
\
POS_FILE = 'kalshi_positions.json'\
LOG_FILE = 'kalshi_bot.log'\
CONFIG_FILE = 'kalshi_config.json'\
\
positions = \{\}\
logs = []\
arb_opps = []\
\
BUY_ARB_THRESHOLD = 99\
SELL_ARB_THRESHOLD = 101\
\
def load_config():\
    if os.path.exists(CONFIG_FILE):\
        with open(CONFIG_FILE, 'r') as f:\
            return json.load(f)\
    return \{\}\
\
config = load_config()\
api_key_id = config.get('api_key_id', '')\
private_key_pem = config.get('private_key_pem', '')\
telegram_token = config.get('telegram_token', '')\
user_chat_id = config.get('user_chat_id', '')\
\
def log_message(msg):\
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\
    full_msg = f"\{timestamp\} - \{msg\}"\
    logs.append(full_msg)\
    with open(LOG_FILE, 'a') as f:\
        f.write(full_msg + '\\n')\
    if len(logs) > 100:\
        logs.pop(0)\
\
def sign_request(method, path):\
    if not api_key_id or not private_key_pem:\
        return None\
    timestamp = str(int(datetime.datetime.now().timestamp()))\
    msg = timestamp + method.upper() + path.split('?')[0]\
    private_key = serialization.load_pem_private_key(\
        private_key_pem.encode(),\
        password=None,\
        backend=default_backend()\
    )\
    sig = private_key.sign(\
        msg.encode(),\
        padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),\
        hashes.SHA256()\
    )\
    sig_base64 = base64.b64encode(sig).decode()\
    headers = \{\
        'Kalshi-Access-Key': api_key_id,\
        'Kalshi-Access-Signature': sig_base64,\
        'Kalshi-Access-Timestamp': timestamp\
    \}\
    return headers\
\
async def fetch_positions():\
    global positions\
    path = '/trade-api/v2/portfolio/positions'\
    headers = sign_request('GET', path)\
    if not headers:\
        log_message("Missing Kalshi credentials.")\
        return\
    url = 'https://trading-api.kalshi.com' + path\
    try:\
        resp = requests.get(url, headers=headers)\
        if resp.status_code == 200:\
            data = resp.json()\
            positions = \{\}\
            for pos in data.get('positions', []):\
                mid = pos.get('market_ticker')\
                positions[mid] = \{\
                    'side': pos.get('side'),\
                    'qty': pos.get('open_quantity', 0),\
                    'entry_price': pos.get('avg_price_paid', 0)\
                \}\
            with open(POS_FILE, 'w') as f:\
                json.dump(positions, f)\
            log_message("Positions updated.")\
        else:\
            log_message(f"Positions fetch failed: \{resp.status_code\} - \{resp.text\}")\
    except Exception as e:\
        log_message(f"Positions error: \{e\}")\
\
async def poll_kalshi():\
    while True:\
        log_message("Polling Kalshi markets...")\
        url = 'https://trading-api.kalshi.com/trade-api/v2/markets?status=open&limit=500'\
        try:\
            resp = requests.get(url)\
            if resp.status_code == 200:\
                markets = resp.json()['markets']\
                new_opps = []\
                for market in markets:\
                    ticker = market['ticker']\
                    ob_url = f'https://trading-api.kalshi.com/trade-api/v2/markets/\{ticker\}/orderbook'\
                    ob_resp = requests.get(ob_url)\
                    if ob_resp.status_code == 200:\
                        ob = ob_resp.json()['orderbook']\
                        yes_bids = ob.get('yes', [])\
                        no_bids = ob.get('no', [])\
                        if yes_bids and no_bids:\
                            best_yes_bid = yes_bids[0][0]\
                            best_no_bid = no_bids[0][0]\
                            sum_bids = best_yes_bid + best_no_bid\
                            yes_ask = 100 - best_no_bid\
                            no_ask = 100 - best_yes_bid\
                            sum_asks = yes_ask + no_ask\
                            if sum_bids > SELL_ARB_THRESHOLD:\
                                new_opps.append(\{'market': ticker, 'type': 'sell arb', 'value': sum_bids\})\
                            if sum_asks < BUY_ARB_THRESHOLD:\
                                new_opps.append(\{'market': ticker, 'type': 'buy arb', 'value': sum_asks\})\
                arb_opps.clear()\
                arb_opps.extend(new_opps)\
                if new_opps and user_chat_id:\
                    msg = f"Found \{len(new_opps)\} arbitrage opportunities!"\
                    try:\
                        await application.bot.send_message(chat_id=user_chat_id, text=msg)\
                    except:\
                        pass\
                log_message(f"Detected \{len(new_opps)\} arbs")\
            else:\
                log_message("Failed to get markets")\
        except Exception as e:\
            log_message(f"Poll error: \{e\}")\
        await asyncio.sleep(30)\
\
async def send_data(websocket, path):\
    while True:\
        data = \{"positions": positions, "logs": logs, "arb_opps": arb_opps\}\
        try:\
            await websocket.send(json.dumps(data))\
        except:\
            pass\
        await asyncio.sleep(5)\
\
async def main():\
    log_message("GrokKalshiArb starting...")\
    if os.path.exists(POS_FILE):\
        with open(POS_FILE, 'r') as f:\
            global positions\
            positions = json.load(f)\
    if os.path.exists(LOG_FILE):\
        with open(LOG_FILE, 'r') as f:\
            global logs\
            logs = f.read().splitlines()[-100:]\
\
    asyncio.create_task(poll_kalshi())\
    if api_key_id and private_key_pem:\
        asyncio.create_task(fetch_positions_periodic())\
\
    server = await websockets.serve(send_data, "127.0.0.1", 8765)\
    await server.wait_closed()\
\
async def fetch_positions_periodic():\
    while True:\
        await fetch_positions()\
        await asyncio.sleep(60)\
\
def run_telegram():\
    global application\
    application = ApplicationBuilder().token(telegram_token).build()\
\
    async def start(update: Update, context: CallbackContext):\
        chat_id = update.effective_chat.id\
        log_message(f"Telegram /start from chat_id: \{chat_id\}")\
        if not user_chat_id:\
            log_message(f"ADD THIS TO config: \\"user_chat_id\\": \\"\{chat_id\}\\"")\
        await update.message.reply_text("GrokKalshiArb online!\\nCommands: /status /positions /arbs /logs")\
\
    async def status(update: Update, context: CallbackContext):\
        await update.message.reply_text(f"Running\\nPositions: \{len(positions)\}\\nArbs: \{len(arb_opps)\}")\
\
    async def positions_cmd(update: Update, context: CallbackContext):\
        text = json.dumps(positions, indent=2) if positions else "No positions yet"\
        await update.message.reply_text(text)\
\
    async def arbs(update: Update, context: CallbackContext):\
        text = json.dumps(arb_opps, indent=2) if arb_opps else "No arbs right now"\
        await update.message.reply_text(text)\
\
    async def logs_cmd(update: Update, context: CallbackContext):\
        text = "\\n".join(logs[-15:]) if logs else "No logs"\
        await update.message.reply_text(text)\
\
    application.add_handler(CommandHandler("start", start))\
    application.add_handler(CommandHandler("status", status))\
    application.add_handler(CommandHandler("positions", positions_cmd))\
    application.add_handler(CommandHandler("arbs", arbs))\
    application.add_handler(CommandHandler("logs", logs_cmd))\
\
    application.run_polling()\
\
if __name__ == "__main__":\
    if telegram_token:\
        threading.Thread(target=run_telegram, daemon=True).start()\
    asyncio.run(main())}